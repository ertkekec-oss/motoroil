[{"filePath":"C:\\Users\\ertke\\OneDrive\\Masa├╝st├╝\\periodya\\muhasebeapp\\motoroil\\src\\lib\\auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":38,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1443,1446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1443,1446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":75,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":75,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2485,2488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2485,2488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":82,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":82,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3112,3115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3112,3115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":115,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":115,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3821,3824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3821,3824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":150,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4644,4647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4644,4647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import bcrypt from 'bcryptjs';\r\nimport { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\n\r\n// SECURITY: JWT_SECRET must be set in production\r\nconst getJWTSecret = () => {\r\n    const secret = process.env.JWT_SECRET;\r\n\r\n    if (!secret) {\r\n        if (process.env.NODE_ENV === 'production') {\r\n            throw new Error('CRITICAL SECURITY ERROR: JWT_SECRET environment variable must be set in production!');\r\n        }\r\n        console.warn('ÔÜá´©Å WARNING: Using default JWT_SECRET in development. DO NOT use in production!');\r\n        return 'dev-only-secret-key-change-in-production';\r\n    }\r\n\r\n    if (secret.length < 32) {\r\n        throw new Error('JWT_SECRET must be at least 32 characters long for security');\r\n    }\r\n\r\n    return secret;\r\n};\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(getJWTSecret());\r\n\r\nexport async function hashPassword(password: string) {\r\n    return await bcrypt.hash(password, 10);\r\n}\r\n\r\nexport async function comparePassword(password: string, hash: string) {\r\n    try {\r\n        // If hash starts with $2a or $2b, it's a bcrypt hash\r\n        if (hash.startsWith('$2a$') || hash.startsWith('$2y$') || hash.startsWith('$2b$')) {\r\n            return await bcrypt.compare(password, hash);\r\n        }\r\n        // Fallback for plain text (migration period)\r\n        return password === hash;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function createSession(user: any) {\r\n    const token = await new SignJWT({\r\n        id: user.id,\r\n        username: user.username,\r\n        role: user.role,\r\n        tenantId: user.tenantId, // Add tenantId to session\r\n        setupState: user.setupState || 'COMPLETED',\r\n        branch: user.branch,\r\n        permissions: user.permissions\r\n    })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('24h')\r\n        .sign(JWT_SECRET);\r\n\r\n    const cookieStore = await cookies();\r\n    cookieStore.set('session', token, {\r\n        httpOnly: true,\r\n        secure: process.env.NODE_ENV === 'production',\r\n        sameSite: 'lax',\r\n        path: '/',\r\n        maxAge: 60 * 60 * 24 // 24 hours\r\n    });\r\n\r\n    return token;\r\n}\r\n\r\nexport async function getSession() {\r\n    let token: string | undefined;\r\n    try {\r\n        const cookieStore = await cookies();\r\n        token = cookieStore.get('session')?.value;\r\n    } catch (e) {\r\n        // Not in a request context (e.g. background job, script)\r\n    }\r\n\r\n    let headersList: any = null;\r\n    try {\r\n        headersList = await (await import('next/headers')).headers();\r\n    } catch (e) {\r\n        // Not in a request context\r\n    }\r\n\r\n    const cronSecret = headersList?.get('x-cron-secret');\r\n\r\n    if (cronSecret && cronSecret === process.env.CRON_SECRET) {\r\n        return {\r\n            id: 'SYSTEM',\r\n            username: 'SYSTEM_CRON',\r\n            role: 'PLATFORM_ADMIN',\r\n            tenantId: 'PLATFORM_ADMIN',\r\n            isSystem: true\r\n        };\r\n    }\r\n\r\n    if (!token) return null;\r\n\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n        const session: any = { ...payload };\r\n\r\n        // Support for Platform Admin Impersonation\r\n        const role = session.role?.toUpperCase() || '';\r\n        if (session.tenantId === 'PLATFORM_ADMIN' || role === 'SUPER_ADMIN') {\r\n            const targetTenantId = headersList?.get('x-target-tenant-id');\r\n            if (targetTenantId) {\r\n                session.impersonateTenantId = targetTenantId;\r\n                session.isImpersonating = true;\r\n            }\r\n        }\r\n\r\n        return session;\r\n    } catch (err) {\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function deleteSession() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('session');\r\n}\r\n\r\nexport function hasPermission(session: any, permission: string): boolean {\r\n    if (!session) return false;\r\n\r\n    // Super admins have all permissions\r\n    const role = session.role?.toUpperCase() || '';\r\n    if (role === 'SUPER_ADMIN' || role.includes('ADMIN')) return true;\r\n\r\n    // Check permissions array\r\n    const permissions = session.permissions || [];\r\n    if (permissions.includes('*') || permissions.includes('ALL')) return true;\r\n\r\n    return permissions.includes(permission);\r\n}\r\n\r\nexport async function authorize() {\r\n    const session = await getSession();\r\n    if (!session) {\r\n        return {\r\n            authorized: false,\r\n            response: Response.json({ success: false, error: 'Oturum gerekli.' }, { status: 401 })\r\n        };\r\n    }\r\n    return { authorized: true, user: session };\r\n}\r\n\r\nexport function verifyWriteAccess(session: any) {\r\n    if (session?.role?.toUpperCase() === 'AUDITOR') {\r\n        return {\r\n            authorized: false,\r\n            response: Response.json({ success: false, error: 'Denet├ği hesab─▒ veri giri┼şi yapamaz (Read-only).' }, { status: 403 })\r\n        };\r\n    }\r\n    return { authorized: true };\r\n}\r\n","usedDeprecatedRules":[]}]
